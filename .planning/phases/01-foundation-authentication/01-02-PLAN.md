---
phase: 01-foundation-authentication
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/auth.ts
  - src/app/api/auth/[...nextauth]/route.ts
  - src/lib/password.ts
  - src/lib/email/client.ts
  - src/lib/email/templates/verify-email.ts
  - src/lib/email/templates/approved.ts
  - src/lib/email/templates/password-reset.ts
  - src/lib/email/templates/index.ts
  - src/lib/email/send.ts
  - src/lib/api-keys.ts
  - src/lib/redis.ts
  - src/middleware.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Auth.js configuration uses database sessions (not JWT)"
    - "Password hashing uses argon2"
    - "Email client can connect to SMTP server"
    - "API key utilities generate, validate, and mask keys"
    - "Middleware protects routes requiring authentication"
  artifacts:
    - path: "src/auth.ts"
      provides: "Auth.js v5 configuration"
      exports: ["handlers", "auth", "signIn", "signOut"]
      contains: "strategy: 'database'"
    - path: "src/lib/password.ts"
      provides: "Password hashing and verification"
      exports: ["hashPassword", "verifyPassword"]
    - path: "src/lib/email/client.ts"
      provides: "SMTP email transport"
      exports: ["getEmailTransporter"]
    - path: "src/lib/api-keys.ts"
      provides: "API key generation and validation"
      exports: ["generateApiKey", "validateApiKey", "maskKey"]
    - path: "src/middleware.ts"
      provides: "Route protection"
      contains: "auth"
  key_links:
    - from: "src/auth.ts"
      to: "src/db/schema/*"
      via: "DrizzleAdapter"
      pattern: "DrizzleAdapter\\(db\\)"
    - from: "src/auth.ts"
      to: "src/lib/password.ts"
      via: "verifyPassword import"
      pattern: "verifyPassword"
    - from: "src/middleware.ts"
      to: "src/auth.ts"
      via: "auth import"
      pattern: "auth"
---

<objective>
Configure Auth.js v5 with database sessions and create core utility functions for password hashing, email sending, and API key management.

Purpose: Establish the authentication infrastructure that signup, login, and API key flows depend on. Using database sessions (not JWT) is critical for the admin approval workflow where user status can change.

Output: Working Auth.js configuration, password utilities (argon2), email client with templates, API key utilities, and middleware for route protection.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-authentication/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Auth.js v5 configuration</name>
  <files>
    src/auth.ts
    src/app/api/auth/[...nextauth]/route.ts
    src/middleware.ts
  </files>
  <action>
    Configure Auth.js v5 with credentials provider and database sessions.

    **src/auth.ts:**
    ```typescript
    import NextAuth from "next-auth"
    import Credentials from "next-auth/providers/credentials"
    import { DrizzleAdapter } from "@auth/drizzle-adapter"
    import { db } from "@/db"
    import { verifyPassword } from "@/lib/password"
    import { users } from "@/db/schema/users"
    import { eq } from "drizzle-orm"
    import type { NextAuthConfig } from "next-auth"

    // Critical: Use database sessions for mutable user state (approval status)
    export const config: NextAuthConfig = {
      adapter: DrizzleAdapter(db),
      session: {
        strategy: "database", // REQUIRED for admin approval state changes
        maxAge: 7 * 24 * 60 * 60, // 7 days default (without "remember me")
        updateAge: 24 * 60 * 60, // Update session once per day
      },
      providers: [
        Credentials({
          credentials: {
            email: { label: "Email", type: "email" },
            password: { label: "Password", type: "password" },
            rememberMe: { label: "Remember me", type: "checkbox" },
          },
          authorize: async (credentials) => {
            if (!credentials?.email || !credentials?.password) {
              return null
            }

            const { email, password, rememberMe } = credentials as {
              email: string
              password: string
              rememberMe?: string
            }

            const user = await db.query.users.findFirst({
              where: eq(users.email, email),
            })

            if (!user || !user.passwordHash) {
              return null
            }

            // CRITICAL: Check approval status BEFORE password verification
            if (user.status !== "approved") {
              throw new Error("Account pending approval or rejected")
            }

            // Check email verified
            if (!user.emailVerified) {
              throw new Error("Email not verified. Please check your inbox.")
            }

            // Check soft delete
            if (user.deletedAt) {
              throw new Error("Account not found")
            }

            const valid = await verifyPassword(password, user.passwordHash)
            if (!valid) {
              return null
            }

            return {
              id: user.id,
              email: user.email,
              role: user.role,
              rememberMe: rememberMe === "on",
            }
          },
        }),
      ],
      callbacks: {
        async session({ session, user }) {
          // Add role and id to session from database user
          if (session.user) {
            session.user.id = user.id
            session.user.role = user.role
          }
          return session
        },
      },
      pages: {
        signIn: "/login",
        error: "/login",
      },
    }

    export const { handlers, auth, signIn, signOut } = NextAuth(config)
    ```

    **src/app/api/auth/[...nextauth]/route.ts:**
    ```typescript
    import { handlers } from "@/auth"

    export const { GET, POST } = handlers
    ```

    **src/middleware.ts:**
    ```typescript
    import { auth } from "@/auth"
    import { NextResponse } from "next/server"

    export default auth((req) => {
      const { nextUrl, auth: session } = req
      const isLoggedIn = !!session

      // Protected routes
      const protectedPaths = ["/settings", "/admin"]
      const isProtectedPath = protectedPaths.some((path) =>
        nextUrl.pathname.startsWith(path)
      )

      if (isProtectedPath && !isLoggedIn) {
        const loginUrl = new URL("/login", nextUrl.origin)
        loginUrl.searchParams.set("callbackUrl", nextUrl.pathname)
        return NextResponse.redirect(loginUrl)
      }

      // Admin-only routes
      const adminPaths = ["/admin"]
      const isAdminPath = adminPaths.some((path) =>
        nextUrl.pathname.startsWith(path)
      )

      if (isAdminPath && session?.user?.role !== "admin") {
        return NextResponse.redirect(new URL("/?error=unauthorized", nextUrl.origin))
      }

      return NextResponse.next()
    })

    export const config = {
      matcher: ["/((?!api|_next/static|_next/image|favicon.ico).*)"],
    }
    ```

    **Extend Auth.js types (create src/types/next-auth.d.ts):**
    ```typescript
    import type { DefaultSession } from "next-auth"
    import type { userRoleEnum } from "@/db/schema/users"

    declare module "next-auth" {
      interface Session {
        user: {
          id: string
          role: typeof userRoleEnum.enumValues[number]
        } & DefaultSession["user"]
      }
      interface User {
        role: typeof userRoleEnum.enumValues[number]
        rememberMe?: boolean
      }
    }

    declare module "next-auth/jwt" {
      interface JWT {
        id: string
        role: typeof userRoleEnum.enumValues[number]
      }
    }
    ```

    **CRITICAL:** Must use `strategy: "database"` not JWT, because user approval status can change after login and we need to check it on each request.
  </action>
  <verify>
    - `cat src/auth.ts | grep "strategy.*database"` confirms database sessions
    - `cat src/auth.ts | grep "status.*approved"` confirms approval check
    - `cat src/middleware.ts | grep "role.*admin"` confirms admin route protection
    - `npx tsc --noEmit` passes
  </verify>
  <done>
    - Auth.ts exports handlers, auth, signIn, signOut
    - Credentials provider configured with email/password
    - Database sessions enabled (strategy: "database")
    - Authorization checks: email verified, status approved, not soft-deleted
    - Session callback adds user.id and user.role to session
    - Middleware protects /settings and /admin routes
    - Admin-only middleware blocks non-admins from /admin/*
    - TypeScript types extended for role field
  </done>
</task>

<task type="auto">
  <name>Task 2: Create password hashing and email utilities</name>
  <files>
    src/lib/password.ts
    src/lib/email/client.ts
    src/lib/email/templates/verify-email.ts
    src/lib/email/templates/approved.ts
    src/lib/email/templates/password-reset.ts
    src/lib/email/templates/index.ts
    src/lib/email/send.ts
  </files>
  <action>
    Create argon2 password utilities and nodemailer email client with templates.

    **src/lib/password.ts:**
    ```typescript
    import * as argon2 from "argon2"

    /**
     * Hash a password using argon2
     * Argon2 is preferred over bcrypt for resistance to GPU attacks
     */
    export async function hashPassword(password: string): Promise<string> {
      return argon2.hash(password, {
        type: argon2.argon2id,
        memoryCost: 19456, // 19 MiB
        timeCost: 2,
        parallelism: 1,
      })
    }

    /**
     * Verify a password against a hash
     */
    export async function verifyPassword(
      password: string,
      hash: string
    ): Promise<boolean> {
      try {
        return await argon2.verify(hash, password)
      } catch {
        return false
      }
    }
    ```

    **src/lib/email/client.ts:**
    ```typescript
    import { createTransport, Transporter } from "nodemailer"

    let transporter: Transporter | null = null

    export function getEmailTransporter(): Transporter {
      if (transporter) return transporter

      // Validate required env vars
      if (!process.env.SMTP_HOST || !process.env.SMTP_USER) {
        console.warn("SMTP configuration missing - emails will not be sent")
      }

      transporter = createTransport({
        host: process.env.SMTP_HOST || "localhost",
        port: parseInt(process.env.SMTP_PORT || "587"),
        secure: process.env.SMTP_SECURE === "true",
        auth:
          process.env.SMTP_USER && process.env.SMTP_PASSWORD
            ? {
                user: process.env.SMTP_USER,
                pass: process.env.SMTP_PASSWORD,
              }
            : undefined,
        // Don't fail on invalid certs in development
        tls:
          process.env.NODE_ENV === "development"
            ? { rejectUnauthorized: false }
            : undefined,
      })

      return transporter
    }
    ```

    **src/lib/email/templates/verify-email.ts:**
    ```typescript
    export function getVerifyEmailTemplate(
      verificationUrl: string,
      host: string
    ) {
      return {
        subject: `Verify your email for ${host}`,
        html: `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
          </head>
          <body style="background: #f9f9f9; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
            <table width="100%" style="max-width: 600px; margin: 40px auto; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
              <tr>
                <td style="padding: 40px; text-align: center;">
                  <h1 style="margin: 0 0 20px; color: #333;">Verify Your Email</h1>
                  <p style="color: #666; margin-bottom: 30px;">
                    Click the button below to verify your email address and continue your registration.
                  </p>
                  <a href="${verificationUrl}" style="display: inline-block; background: #346df1; color: white; padding: 14px 28px; text-decoration: none; border-radius: 6px; font-weight: 500;">
                    Verify Email Address
                  </a>
                  <p style="color: #999; font-size: 13px; margin-top: 30px;">
                    This link will expire in 24 hours. If you did not create an account, you can safely ignore this email.
                  </p>
                </td>
              </tr>
            </table>
          </body>
          </html>
        `,
        text: `Verify your email for ${host}\n\nClick this link to verify your email: ${verificationUrl}\n\nThis link expires in 24 hours. If you did not request this, ignore this email.`,
      }
    }
    ```

    **src/lib/email/templates/approved.ts:**
    ```typescript
    export function getApprovedEmailTemplate(loginUrl: string, host: string) {
      return {
        subject: `Your account has been approved - ${host}`,
        html: `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
          </head>
          <body style="background: #f9f9f9; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
            <table width="100%" style="max-width: 600px; margin: 40px auto; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
              <tr>
                <td style="padding: 40px; text-align: center;">
                  <h1 style="margin: 0 0 20px; color: #333;">Account Approved!</h1>
                  <p style="color: #666; margin-bottom: 30px;">
                    Great news! Your account has been approved by an administrator. You can now log in and start using the platform.
                  </p>
                  <a href="${loginUrl}" style="display: inline-block; background: #10b981; color: white; padding: 14px 28px; text-decoration: none; border-radius: 6px; font-weight: 500;">
                    Log In Now
                  </a>
                  <p style="color: #999; font-size: 13px; margin-top: 30px;">
                    If you have any questions, please contact your administrator.
                  </p>
                </td>
              </tr>
            </table>
          </body>
          </html>
        `,
        text: `Your account has been approved!\n\nYou can now log in at: ${loginUrl}\n\nWelcome to ${host}!`,
      }
    }
    ```

    **src/lib/email/templates/password-reset.ts:**
    ```typescript
    export function getPasswordResetTemplate(
      resetUrl: string,
      host: string
    ) {
      return {
        subject: `Reset your password - ${host}`,
        html: `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
          </head>
          <body style="background: #f9f9f9; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
            <table width="100%" style="max-width: 600px; margin: 40px auto; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
              <tr>
                <td style="padding: 40px; text-align: center;">
                  <h1 style="margin: 0 0 20px; color: #333;">Reset Your Password</h1>
                  <p style="color: #666; margin-bottom: 30px;">
                    We received a request to reset your password. Click the button below to create a new password.
                  </p>
                  <a href="${resetUrl}" style="display: inline-block; background: #346df1; color: white; padding: 14px 28px; text-decoration: none; border-radius: 6px; font-weight: 500;">
                    Reset Password
                  </a>
                  <p style="color: #999; font-size: 13px; margin-top: 30px;">
                    This link will expire in 1 hour. If you did not request a password reset, you can safely ignore this email.
                  </p>
                </td>
              </tr>
            </table>
          </body>
          </html>
        `,
        text: `Reset your password for ${host}\n\nClick this link to reset your password: ${resetUrl}\n\nThis link expires in 1 hour. If you did not request this, ignore this email.`,
      }
    }
    ```

    **src/lib/email/templates/index.ts:**
    ```typescript
    export { getVerifyEmailTemplate } from "./verify-email"
    export { getApprovedEmailTemplate } from "./approved"
    export { getPasswordResetTemplate } from "./password-reset"
    ```

    **src/lib/email/send.ts:**
    ```typescript
    import { getEmailTransporter } from "./client"
    import {
      getVerifyEmailTemplate,
      getApprovedEmailTemplate,
      getPasswordResetTemplate,
    } from "./templates"

    const fromEmail = process.env.EMAIL_FROM || "noreply@example.com"
    const appUrl = process.env.NEXTAUTH_URL || "http://localhost:3000"

    export async function sendVerificationEmail(
      email: string,
      token: string
    ): Promise<void> {
      const verificationUrl = `${appUrl}/verify-email?token=${token}`
      const host = new URL(appUrl).host
      const template = getVerifyEmailTemplate(verificationUrl, host)

      const transporter = getEmailTransporter()
      await transporter.sendMail({
        from: fromEmail,
        to: email,
        subject: template.subject,
        html: template.html,
        text: template.text,
      })
    }

    export async function sendApprovalEmail(email: string): Promise<void> {
      const loginUrl = `${appUrl}/login`
      const host = new URL(appUrl).host
      const template = getApprovedEmailTemplate(loginUrl, host)

      const transporter = getEmailTransporter()
      await transporter.sendMail({
        from: fromEmail,
        to: email,
        subject: template.subject,
        html: template.html,
        text: template.text,
      })
    }

    export async function sendPasswordResetEmail(
      email: string,
      token: string
    ): Promise<void> {
      const resetUrl = `${appUrl}/reset-password?token=${token}`
      const host = new URL(appUrl).host
      const template = getPasswordResetTemplate(resetUrl, host)

      const transporter = getEmailTransporter()
      await transporter.sendMail({
        from: fromEmail,
        to: email,
        subject: template.subject,
        html: template.html,
        text: template.text,
      })
    }
    ```

    **Note:** Emails will not actually send until SMTP is configured in .env.local - that's expected.
  </action>
  <verify>
    - `cat src/lib/password.ts | grep "argon2"` confirms argon2 usage
    - `cat src/lib/email/send.ts | grep "sendVerificationEmail"` confirms email sending function
    - `cat src/lib/email/send.ts | grep "sendApprovalEmail"` confirms approval email function
    - `cat src/lib/email/send.ts | grep "sendPasswordResetEmail"` confirms password reset function
    - `npx tsc --noEmit` passes
  </verify>
  <done>
    - Password hashing uses argon2 with argon2id algorithm
    - Email client configured for SMTP with environment variables
    - Three email templates created: verify-email, approved, password-reset
    - sendVerificationEmail, sendApprovalEmail, sendPasswordResetEmail functions exported
    - All templates include both HTML and plain text versions
  </done>
</task>

<task type="auto">
  <name>Task 3: Create API key utilities and Redis client</name>
  <files>
    src/lib/api-keys.ts
    src/lib/redis.ts
  </files>
  <action>
    Create API key generation/validation utilities and optional Redis client.

    **src/lib/api-keys.ts:**
    ```typescript
    import { randomBytes, createHash } from "crypto"
    import { db } from "@/db"
    import { apiKeys } from "@/db/schema/api-keys"
    import { eq } from "drizzle-orm"

    const KEY_PREFIX = "pk_live_" // Identifiable prefix for Pipelite keys

    interface CreateApiKeyResult {
      fullKey: string // Only shown ONCE on creation
      keyPrefix: string // Stored for display (first 12 chars)
      id: string
    }

    /**
     * Generate a new API key for a user
     * - Creates 32 random bytes, base64url encoded
     * - Stores SHA-256 hash only (never store full key)
     * - Returns full key ONCE - cannot be retrieved again
     */
    export async function generateApiKey(
      userId: string,
      name: string
    ): Promise<CreateApiKeyResult> {
      // Generate random key material
      const randomPart = randomBytes(32).toString("base64url")
      const fullKey = `${KEY_PREFIX}${randomPart}`

      // Hash for storage - NEVER store full key
      const keyHash = createHash("sha256").update(fullKey).digest("hex")
      const keyPrefix = fullKey.slice(0, 12) // pk_live_abc1

      const [apiKey] = await db
        .insert(apiKeys)
        .values({
          userId,
          name,
          keyPrefix,
          keyHash,
        })
        .returning()

      return {
        fullKey, // Return once - caller must display immediately
        keyPrefix: apiKey.keyPrefix,
        id: apiKey.id,
      }
    }

    /**
     * Validate an API key and return the associated user
     * - Hashes the provided key and compares to stored hash
     * - Updates lastUsedAt timestamp
     * - Returns null if key not found or soft-deleted
     */
    export async function validateApiKey(
      key: string
    ): Promise<{ userId: string; keyId: string } | null> {
      if (!key.startsWith(KEY_PREFIX)) {
        return null
      }

      const keyHash = createHash("sha256").update(key).digest("hex")

      const apiKey = await db.query.apiKeys.findFirst({
        where: eq(apiKeys.keyHash, keyHash),
      })

      if (!apiKey || apiKey.deletedAt) {
        return null
      }

      // Update last used timestamp (async, don't await)
      db.update(apiKeys)
        .set({ lastUsedAt: new Date() })
        .where(eq(apiKeys.id, apiKey.id))
        .execute()
        .catch(console.error)

      return {
        userId: apiKey.userId,
        keyId: apiKey.id,
      }
    }

    /**
     * Regenerate an API key (creates new key value, keeps name)
     * - Soft deletes old key by setting deletedAt
     * - Creates new key with same name
     * - Returns full key ONCE
     */
    export async function regenerateApiKey(
      keyId: string,
      userId: string
    ): Promise<CreateApiKeyResult | null> {
      // Get existing key
      const existingKey = await db.query.apiKeys.findFirst({
        where: eq(apiKeys.id, keyId),
      })

      if (!existingKey || existingKey.userId !== userId || existingKey.deletedAt) {
        return null
      }

      // Soft delete old key
      await db
        .update(apiKeys)
        .set({ deletedAt: new Date() })
        .where(eq(apiKeys.id, keyId))

      // Generate new key with same name
      return generateApiKey(userId, existingKey.name)
    }

    /**
     * Mask a key for display (show prefix and last 4 chars)
     * e.g., pk_live_abc1****xyz9
     */
    export function maskKey(key: string): string {
      if (key.length < 16) return key
      return key.slice(0, 12) + "****" + key.slice(-4)
    }

    /**
     * Mask from stored keyPrefix (for display when full key not available)
     * e.g., pk_live_abc1**** (without suffix)
     */
    export function maskFromPrefix(keyPrefix: string): string {
      return keyPrefix + "****"
    }
    ```

    **src/lib/redis.ts:**
    ```typescript
    import Redis from "ioredis"

    let redis: Redis | null = null

    /**
     * Get Redis client (optional - for session caching)
     * Returns null if REDIS_URL is not configured
     */
    export function getRedisClient(): Redis | null {
      if (redis) return redis

      if (!process.env.REDIS_URL) {
        console.info("REDIS_URL not configured - using database sessions only")
        return null
      }

      try {
        redis = new Redis(process.env.REDIS_URL, {
          maxRetriesPerRequest: 3,
          retryDelayOnFailover: 100,
          lazyConnect: true,
        })

        redis.on("error", (err) => {
          console.error("Redis connection error:", err)
        })

        redis.on("connect", () => {
          console.info("Redis connected successfully")
        })

        return redis
      } catch (error) {
        console.error("Failed to initialize Redis:", error)
        return null
      }
    }

    /**
     * Cache helper with TTL
     */
    export async function cacheGet<T>(
      key: string,
      fetcher: () => Promise<T>,
      ttlSeconds: number = 300
    ): Promise<T> {
      const client = getRedisClient()

      if (client) {
        const cached = await client.get(key)
        if (cached) {
          return JSON.parse(cached) as T
        }
      }

      const data = await fetcher()

      if (client) {
        await client.setex(key, ttlSeconds, JSON.stringify(data))
      }

      return data
    }

    /**
     * Invalidate cache key
     */
    export async function cacheInvalidate(key: string): Promise<void> {
      const client = getRedisClient()
      if (client) {
        await client.del(key)
      }
    }
    ```

    **Note:** Redis is optional. Auth.js doesn't natively support Redis caching, so this is for future use. The app works fine with database-only sessions.
  </action>
  <verify>
    - `cat src/lib/api-keys.ts | grep "KEY_PREFIX.*pk_live_"` confirms key prefix
    - `cat src/lib/api-keys.ts | grep "sha256"` confirms hash storage
    - `cat src/lib/api-keys.ts | grep "generateApiKey"` confirms generation function
    - `cat src/lib/api-keys.ts | grep "validateApiKey"` confirms validation function
    - `cat src/lib/api-keys.ts | grep "regenerateApiKey"` confirms regeneration function
    - `cat src/lib/api-keys.ts | grep "maskKey"` confirms masking function
    - `npx tsc --noEmit` passes
  </verify>
  <done>
    - API keys use pk_live_ prefix format
    - Full keys are SHA-256 hashed before storage
    - generateApiKey returns full key ONCE, stores hash only
    - validateApiKey verifies against hash, updates lastUsedAt
    - regenerateApiKey soft-deletes old key, creates new with same name
    - maskKey and maskFromPrefix for secure display
    - Redis client available but optional (graceful degradation)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` passes with no errors
2. Auth.js configured with database sessions
3. Password hashing uses argon2
4. Email client with 3 templates (verify, approved, password-reset)
5. API key utilities with hash storage, validation, regeneration
6. Middleware protects routes
</verification>

<success_criteria>
- Auth.ts exports handlers, auth, signIn, signOut with database sessions
- Credentials provider checks: email verified, status approved, not deleted
- Session includes user.id and user.role
- Middleware blocks unauthenticated access to /settings and /admin
- Middleware blocks non-admin access to /admin/*
- Password hashing uses argon2id algorithm
- Email client connects to SMTP, sends via 3 templates
- API key utilities: generate (hash storage), validate (hash compare), regenerate (soft delete + new), mask
- Redis client available with graceful degradation when not configured
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-02-SUMMARY.md`
</output>
