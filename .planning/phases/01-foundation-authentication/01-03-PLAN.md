---
phase: 01-foundation-authentication
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/app/api/signup/route.ts
  - src/app/(auth)/signup/page.tsx
  - src/app/(auth)/verify-email/page.tsx
  - src/app/api/verify-email/route.ts
  - src/app/(auth)/layout.tsx
  - src/types/next-auth.d.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can submit signup form with email and password"
    - "Domain whitelist is checked BEFORE verification email is sent"
    - "Verification email is sent after successful signup"
    - "User can click email link to verify their email"
    - "User status changes from pending_verification to pending_approval after verification"
    - "User sees appropriate messages at each step"
  artifacts:
    - path: "src/app/api/signup/route.ts"
      provides: "Signup API endpoint"
      exports: ["POST"]
      contains: "pending_verification"
    - path: "src/app/(auth)/signup/page.tsx"
      provides: "Signup form UI"
      contains: "email, password"
    - path: "src/app/(auth)/verify-email/page.tsx"
      provides: "Email verification UI"
      contains: "token"
    - path: "src/app/api/verify-email/route.ts"
      provides: "Verification callback handler"
      contains: "pending_approval"
  key_links:
    - from: "src/app/api/signup/route.ts"
      to: "src/lib/password.ts"
      via: "hashPassword"
      pattern: "hashPassword"
    - from: "src/app/api/signup/route.ts"
      to: "src/lib/email/send.ts"
      via: "sendVerificationEmail"
      pattern: "sendVerificationEmail"
    - from: "src/app/api/verify-email/route.ts"
      to: "src/db"
      via: "db.update"
      pattern: "status.*pending_approval"
---

<objective>
Implement the complete signup flow: form submission → domain whitelist check → user creation → email verification → pending approval state.

Purpose: Allow new users to sign up with email and password. The flow enforces domain whitelist, email verification, and prepares users for admin approval.

Output: Working signup form, signup API, verification email sending, and email verification callback that transitions users to pending_approval status.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-authentication/01-01-SUMMARY.md
@.planning/phases/01-foundation-authentication/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create signup API route</name>
  <files>
    src/app/api/signup/route.ts
    src/lib/domain-whitelist.ts
  </files>
  <action>
    Create signup API endpoint with domain whitelist check, user creation, and verification email.

    **src/lib/domain-whitelist.ts:**
    ```typescript
    import { db } from "@/db"
    import { domainWhitelist } from "@/db/schema/domain-whitelist"

    /**
     * Check if an email domain is allowed for signup
     * - If whitelist is empty, all domains are allowed
     * - If whitelist has entries, email domain must match one
     */
    export async function isDomainAllowed(email: string): Promise<boolean> {
      const domain = email.split("@")[1]?.toLowerCase()

      if (!domain) {
        return false
      }

      const whitelist = await db.select().from(domainWhitelist)

      // Empty whitelist = all domains allowed
      if (whitelist.length === 0) {
        return true
      }

      return whitelist.some(
        (entry) => entry.domain.toLowerCase() === domain
      )
    }
    ```

    **src/app/api/signup/route.ts:**
    ```typescript
    import { NextRequest, NextResponse } from "next/server"
    import { db } from "@/db"
    import { users, verificationTokens } from "@/db/schema"
    import { hashPassword } from "@/lib/password"
    import { sendVerificationEmail } from "@/lib/email/send"
    import { isDomainAllowed } from "@/lib/domain-whitelist"
    import { eq } from "drizzle-orm"
    import { z } from "zod"
    import { createHash } from "crypto"

    const signupSchema = z.object({
      email: z.string().email("Invalid email address"),
      password: z.string().min(8, "Password must be at least 8 characters").max(128),
    })

    export async function POST(request: NextRequest) {
      try {
        const body = await request.json()
        
        // Validate input
        const result = signupSchema.safeParse(body)
        if (!result.success) {
          return NextResponse.json(
            { error: result.error.errors[0]?.message || "Invalid input" },
            { status: 400 }
          )
        }

        const { email, password } = result.data
        const normalizedEmail = email.toLowerCase().trim()

        // Check domain whitelist BEFORE checking if user exists
        // This prevents leaking whether an email is registered
        const domainAllowed = await isDomainAllowed(normalizedEmail)
        if (!domainAllowed) {
          return NextResponse.json(
            { error: "Signups from this email domain are not allowed" },
            { status: 400 }
          )
        }

        // Check for existing user
        const existingUser = await db.query.users.findFirst({
          where: eq(users.email, normalizedEmail),
        })

        if (existingUser && !existingUser.deletedAt) {
          // Don't reveal if email exists - return success but don't send email
          // This prevents email enumeration
          return NextResponse.json({
            message: "If this email is available, check your inbox for verification",
          })
        }

        // Hash password
        const passwordHash = await hashPassword(password)

        // Check if this is the first user (becomes admin automatically)
        const existingUsersCount = await db.select({ id: users.id }).from(users)
        const isFirstUser = existingUsersCount.length === 0

        // Create user with pending_verification status
        // First user becomes admin automatically (self-hosted bootstrapping pattern)
        const [user] = await db
          .insert(users)
          .values({
            email: normalizedEmail,
            passwordHash,
            status: "pending_verification",
            role: isFirstUser ? "admin" : "member",
          })
          .returning()

        // Generate verification token
        const rawToken = crypto.randomUUID()
        const tokenHash = createHash("sha256").update(rawToken).digest("hex")

        // Store token hash (expires in 24 hours)
        await db.insert(verificationTokens).values({
          identifier: normalizedEmail,
          token: tokenHash,
          expires: new Date(Date.now() + 24 * 60 * 60 * 1000),
        })

        // Send verification email
        await sendVerificationEmail(normalizedEmail, rawToken)

        return NextResponse.json({
          message: "If this email is available, check your inbox for verification",
        })
      } catch (error) {
        console.error("Signup error:", error)
        return NextResponse.json(
          { error: "An unexpected error occurred" },
          { status: 500 }
        )
      }
    }
    ```

    **CRITICAL:** 
    - Check domain whitelist BEFORE checking if user exists to prevent email enumeration
    - Store token hash, not raw token
    - Always return same message whether email exists or not
    - First signup becomes admin automatically (self-hosted bootstrapping pattern - no users exist yet)
  </action>
  <verify>
    - `cat src/app/api/signup/route.ts | grep "isDomainAllowed"` confirms whitelist check
    - `cat src/app/api/signup/route.ts | grep "pending_verification"` confirms initial status
    - `cat src/app/api/signup/route.ts | grep "sendVerificationEmail"` confirms email sending
    - `cat src/app/api/signup/route.ts | grep "isFirstUser"` confirms first-user admin logic
    - `cat src/lib/domain-whitelist.ts | grep "whitelist.length === 0"` confirms empty = all allowed
    - `npx tsc --noEmit` passes
  </verify>
  <done>
    - POST /api/signup accepts {email, password}
    - Password validated: min 8 characters
    - Domain whitelist checked BEFORE user existence check
    - First user created with role: admin (subsequent users: member)
    - User created with status: pending_verification
    - Verification token generated (SHA-256 hashed for storage)
    - Verification email sent via sendVerificationEmail
    - Consistent response to prevent email enumeration
  </done>
</task>

<task type="auto">
  <name>Task 2: Create signup page UI</name>
  <files>
    src/app/(auth)/signup/page.tsx
    src/app/(auth)/layout.tsx
  </files>
  <action>
    Create signup form with shadcn/ui components and form validation.

    **src/app/(auth)/layout.tsx:**
    ```typescript
    import { Metadata } from "next"

    export const metadata: Metadata = {
      title: "Authentication",
    }

    export default function AuthLayout({
      children,
    }: {
      children: React.ReactNode
    }) {
      return (
        <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
          <div className="w-full max-w-md">
            {children}
          </div>
        </div>
      )
    }
    ```

    **src/app/(auth)/signup/page.tsx:**
    ```typescript
    "use client"

    import { useState } from "react"
    { useRouter } from "next/navigation"
    { useForm } from "react-hook-form"
    { zodResolver } from "@hookform/resolvers/zod"
    { z } from "zod"
    { Button } from "@/components/ui/button"
    { Input } from "@/components/ui/input"
    { Label } from "@/components/ui/label"
    { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
    { Loader2 } from "lucide-react"

    const signupSchema = z.object({
      email: z.string().email("Invalid email address"),
      password: z.string().min(8, "Password must be at least 8 characters"),
    })

    type SignupFormData = z.infer<typeof signupSchema>

    export default function SignupPage() {
      const router = useRouter()
      const [error, setError] = useState<string | null>(null)
      const [isLoading, setIsLoading] = useState(false)

      const {
        register,
        handleSubmit,
        formState: { errors },
      } = useForm<SignupFormData>({
        resolver: zodResolver(signupSchema),
      })

      const onSubmit = async (data: SignupFormData) => {
        setError(null)
        setIsLoading(true)

        try {
          const response = await fetch("/api/signup", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(data),
          })

          const result = await response.json()

          if (!response.ok) {
            setError(result.error || "Signup failed")
            return
          }

          // Redirect to verification page with email
          router.push(`/verify-email?email=${encodeURIComponent(data.email)}`)
        } catch (err) {
          setError("An unexpected error occurred. Please try again.")
        } finally {
          setIsLoading(false)
        }
      }

      return (
        <Card>
          <CardHeader className="space-y-1">
            <CardTitle className="text-2xl font-bold text-center">
              Create an account
            </CardTitle>
            <CardDescription className="text-center">
              Enter your email and password to get started
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
              {error && (
                <div className="p-3 text-sm text-red-600 bg-red-50 border border-red-200 rounded-md">
                  {error}
                </div>
              )}
              
              <div className="space-y-2">
                <Label htmlFor="email">Email</Label>
                <Input
                  id="email"
                  type="email"
                  placeholder="you@example.com"
                  {...register("email")}
                  disabled={isLoading}
                />
                {errors.email && (
                  <p className="text-sm text-red-500">{errors.email.message}</p>
                )}
              </div>

              <div className="space-y-2">
                <Label htmlFor="password">Password</Label>
                <Input
                  id="password"
                  type="password"
                  placeholder="Minimum 8 characters"
                  {...register("password")}
                  disabled={isLoading}
                />
                {errors.password && (
                  <p className="text-sm text-red-500">{errors.password.message}</p>
                )}
              </div>

              <Button type="submit" className="w-full" disabled={isLoading}>
                {isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                Create Account
              </Button>

              <p className="text-center text-sm text-muted-foreground">
                Already have an account?{" "}
                <a href="/login" className="text-primary hover:underline">
                  Sign in
                </a>
              </p>
            </form>
          </CardContent>
        </Card>
      )
    }
    ```

    **Note:** Install lucide-react for icons: `npm install lucide-react`
  </action>
  <verify>
    - `ls src/app/\(auth\)/signup/page.tsx` confirms file exists
    - `cat src/app/\(auth\)/signup/page.tsx | grep "handleSubmit"` confirms form handling
    - `cat src/app/\(auth\)/signup/page.tsx | grep "zodResolver"` confirms validation
    - `npx tsc --noEmit` passes
  </verify>
  <done>
    - Signup form at /signup with email and password fields
    - Form validation using zod (email format, password min 8 chars)
    - Submit calls POST /api/signup
    - On success, redirects to /verify-email?email=...
    - Error messages displayed for validation and API errors
    - Loading state disables form during submission
    - Link to /login for existing users
  </done>
</task>

<task type="auto">
  <name>Task 3: Create email verification page and handler</name>
  <files>
    src/app/(auth)/verify-email/page.tsx
    src/app/api/verify-email/route.ts
  </files>
  <action>
    Create verification callback that transitions users from pending_verification to pending_approval.

    **src/app/(auth)/verify-email/page.tsx:**
    ```typescript
    "use client"

    import { useEffect, useState, Suspense } from "react"
    { useRouter, useSearchParams } from "next/navigation"
    { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
    { Loader2, CheckCircle2, XCircle, Mail } from "lucide-react"
    { Button } from "@/components/ui/button"

    function VerifyEmailContent() {
      const router = useRouter()
      const searchParams = useSearchParams()
      const token = searchParams.get("token")
      const email = searchParams.get("email")
      
      const [status, setStatus] = useState<"loading" | "success" | "error" | "waiting">("waiting")
      const [message, setMessage] = useState<string>("")

      useEffect(() => {
        if (token) {
          verifyEmail(token)
        }
      }, [token])

      const verifyEmail = async (token: string) => {
        setStatus("loading")
        
        try {
          const response = await fetch(`/api/verify-email?token=${token}`)
          const result = await response.json()

          if (response.ok) {
            setStatus("success")
            setMessage(result.message)
          } else {
            setStatus("error")
            setMessage(result.error || "Verification failed")
          }
        } catch (error) {
          setStatus("error")
          setMessage("An unexpected error occurred")
        }
      }

      // Initial state: waiting for user to click email link
      if (!token && status === "waiting") {
        return (
          <Card>
            <CardHeader className="space-y-1">
              <div className="flex justify-center mb-4">
                <Mail className="h-12 w-12 text-primary" />
              </div>
              <CardTitle className="text-2xl font-bold text-center">
                Check your email
              </CardTitle>
              <CardDescription className="text-center">
                {email ? (
                  <>
                    We sent a verification link to{" "}
                    <span className="font-medium">{email}</span>
                  </>
                ) : (
                  "We sent a verification link to your email address"
                )}
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <p className="text-sm text-muted-foreground text-center">
                Click the link in the email to verify your account. 
                After verification, an administrator will review your signup.
              </p>
              <p className="text-xs text-muted-foreground text-center">
                Didn&apos;t receive the email? Check your spam folder or{" "}
                <a href="/signup" className="text-primary hover:underline">
                  try again
                </a>
              </p>
            </CardContent>
          </Card>
        )
      }

      // Loading state: verifying token
      if (status === "loading") {
        return (
          <Card>
            <CardContent className="py-12">
              <div className="flex flex-col items-center gap-4">
                <Loader2 className="h-8 w-8 animate-spin text-primary" />
                <p className="text-muted-foreground">Verifying your email...</p>
              </div>
            </CardContent>
          </Card>
        )
      }

      // Success state: email verified
      if (status === "success") {
        return (
          <Card>
            <CardHeader className="space-y-1">
              <div className="flex justify-center mb-4">
                <CheckCircle2 className="h-12 w-12 text-green-500" />
              </div>
              <CardTitle className="text-2xl font-bold text-center">
                Email verified!
              </CardTitle>
              <CardDescription className="text-center">
                {message || "Your email has been verified successfully."}
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <p className="text-sm text-muted-foreground text-center">
                An administrator will review your signup and notify you when your account is approved.
              </p>
              <Button 
                className="w-full" 
                onClick={() => router.push("/login")}
              >
                Continue to Login
              </Button>
            </CardContent>
          </Card>
        )
      }

      // Error state
      return (
        <Card>
          <CardHeader className="space-y-1">
            <div className="flex justify-center mb-4">
              <XCircle className="h-12 w-12 text-red-500" />
            </div>
            <CardTitle className="text-2xl font-bold text-center">
              Verification failed
            </CardTitle>
            <CardDescription className="text-center">
              {message}
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <Button 
              className="w-full" 
              onClick={() => router.push("/signup")}
            >
              Try Again
            </Button>
          </CardContent>
        </Card>
      )
    }

    export default function VerifyEmailPage() {
      return (
        <Suspense fallback={
          <Card>
            <CardContent className="py-12">
              <div className="flex flex-col items-center gap-4">
                <Loader2 className="h-8 w-8 animate-spin text-primary" />
                <p className="text-muted-foreground">Loading...</p>
              </div>
            </CardContent>
          </Card>
        }>
          <VerifyEmailContent />
        </Suspense>
      )
    }
    ```

    **src/app/api/verify-email/route.ts:**
    ```typescript
    import { NextRequest, NextResponse } from "next/server"
    import { db } from "@/db"
    import { users, verificationTokens } from "@/db/schema"
    import { eq, and, gt } from "drizzle-orm"
    import { createHash } from "crypto"

    export async function GET(request: NextRequest) {
      try {
        const token = request.nextUrl.searchParams.get("token")

        if (!token) {
          return NextResponse.json(
            { error: "Missing verification token" },
            { status: 400 }
          )
        }

        // Hash the token to compare with stored hash
        const tokenHash = createHash("sha256").update(token).digest("hex")

        // Find valid token (not expired)
        const verificationToken = await db.query.verificationTokens.findFirst({
          where: and(
            eq(verificationTokens.token, tokenHash),
            gt(verificationTokens.expires, new Date())
          ),
        })

        if (!verificationToken) {
          return NextResponse.json(
            { error: "Invalid or expired verification token" },
            { status: 400 }
          )
        }

        // Find the user
        const user = await db.query.users.findFirst({
          where: eq(users.email, verificationToken.identifier),
        })

        if (!user) {
          return NextResponse.json(
            { error: "User not found" },
            { status: 400 }
          )
        }

        // Update user status to pending_approval
        await db
          .update(users)
          .set({
            emailVerified: new Date(),
            status: "pending_approval",
            updatedAt: new Date(),
          })
          .where(eq(users.id, user.id))

        // Delete the verification token (one-time use)
        await db
          .delete(verificationTokens)
          .where(eq(verificationTokens.token, tokenHash))

        return NextResponse.json({
          message: "Your email has been verified. An administrator will review your signup.",
        })
      } catch (error) {
        console.error("Email verification error:", error)
        return NextResponse.json(
          { error: "An unexpected error occurred" },
          { status: 500 }
        )
      }
    }
    ```

    **CRITICAL:** After verification, user status becomes `pending_approval` - this is when they appear in the admin panel.
  </action>
  <verify>
    - `cat src/app/api/verify-email/route.ts | grep "pending_approval"` confirms status transition
    - `cat src/app/api/verify-email/route.ts | grep "emailVerified"` confirms timestamp set
    - `cat src/app/\(auth\)/verify-email/page.tsx | grep "Check your email"` confirms waiting state UI
    - `npx tsc --noEmit` passes
  </verify>
  <done>
    - /verify-email page shows "check your email" message initially
    - When token param present, automatically calls /api/verify-email
    - GET /api/verify-email validates token (checks expiry)
    - On success: user.emailVerified set, user.status → pending_approval
    - Verification token deleted (one-time use)
    - Success page shows "email verified, awaiting approval" message
    - Error states for invalid/expired tokens
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` succeeds
2. POST /api/signup creates user with pending_verification status
3. Domain whitelist checked before user creation
4. First signup creates admin user (subsequent signups create member)
5. GET /api/verify-email transitions user to pending_approval
6. Signup form validates email and password (min 8 chars)
7. Verify email page handles waiting, loading, success, error states
</verification>

<success_criteria>
- Signup form at /signup accepts email and password (min 8 chars)
- Domain whitelist check happens BEFORE verification email sent
- First user created with role: admin (self-hosted bootstrapping)
- Subsequent users created with role: member
- User created with status: pending_verification
- Verification email sent with token (token stored as hash)
- /verify-email page shows "check your inbox" message
- Clicking email link verifies token, sets emailVerified, changes status to pending_approval
- Appropriate UI feedback at each step (waiting, loading, success, error)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-03-SUMMARY.md`
</output>
