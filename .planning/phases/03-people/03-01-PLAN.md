---
phase: 03-people
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema/people.ts
  - src/db/schema/_relations.ts
  - src/db/schema/index.ts
  - src/app/people/actions.ts
autonomous: true

must_haves:
  truths:
    - "People table exists in database with firstName, lastName, email, phone, notes, organizationId, ownerId columns"
    - "People can be created with valid data and linked to an organization"
    - "People can be updated by their owner"
    - "People can be soft-deleted by their owner"
    - "Drizzle relations connect people to organizations and users"
  artifacts:
    - path: "src/db/schema/people.ts"
      provides: "People table schema definition"
      contains: "pgTable('people'"
    - path: "src/db/schema/_relations.ts"
      provides: "People relations (org + owner) and updated org relations (many people)"
      contains: "peopleRelations"
    - path: "src/db/schema/index.ts"
      provides: "Barrel export including people"
      contains: "people"
    - path: "src/app/people/actions.ts"
      provides: "CRUD server actions: createPerson, updatePerson, deletePerson"
      exports: ["createPerson", "updatePerson", "deletePerson"]
  key_links:
    - from: "src/db/schema/people.ts"
      to: "src/db/schema/organizations.ts"
      via: "organizationId FK reference"
      pattern: "references.*organizations\\.id"
    - from: "src/db/schema/people.ts"
      to: "src/db/schema/users.ts"
      via: "ownerId FK reference"
      pattern: "references.*users\\.id"
    - from: "src/app/people/actions.ts"
      to: "src/db/schema/people.ts"
      via: "import people schema for db operations"
      pattern: "import.*people.*from.*db/schema"
---

<objective>
Create the people database schema and CRUD server actions mirroring the organizations pattern.

Purpose: Establish the data layer for contact management -- schema, relations, and validated server actions -- so the UI layer can be built on top.
Output: People table schema, updated relations, and three server actions (create, update, delete) with Zod validation.
</objective>

<execution_context>
@/home/pedro/.claude/get-shit-done/workflows/execute-plan.md
@/home/pedro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-people/03-RESEARCH.md
@.planning/phases/02-organizations/02-01-SUMMARY.md

Key reference files (mirror these patterns exactly):
@src/db/schema/organizations.ts
@src/db/schema/_relations.ts
@src/db/schema/index.ts
@src/app/organizations/actions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create people database schema and relations</name>
  <files>
    src/db/schema/people.ts
    src/db/schema/_relations.ts
    src/db/schema/index.ts
  </files>
  <action>
    **Create `src/db/schema/people.ts`** mirroring organizations.ts exactly:
    - Import `pgTable`, `text`, `timestamp` from `drizzle-orm/pg-core`
    - Import `users` from `./users` and `organizations` from `./organizations`
    - Define `people` table with columns:
      - `id`: text primary key with `$defaultFn(() => crypto.randomUUID())`
      - `firstName`: text('first_name').notNull()
      - `lastName`: text('last_name').notNull()
      - `email`: text('email') -- nullable, NO unique constraint (contacts can share emails like info@company.com)
      - `phone`: text('phone') -- nullable
      - `notes`: text('notes') -- nullable
      - `organizationId`: text('organization_id').references(() => organizations.id) -- nullable FK (person may not belong to an org)
      - `ownerId`: text('owner_id').notNull().references(() => users.id)
      - `createdAt`: timestamp('created_at').defaultNow().notNull()
      - `updatedAt`: timestamp('updated_at').defaultNow().notNull()
      - `deletedAt`: timestamp('deleted_at') -- soft delete

    **Update `src/db/schema/_relations.ts`**:
    - Add `import { people } from "./people"` at the top with other imports
    - Add `peopleRelations` definition:
      ```
      export const peopleRelations = relations(people, ({ one }) => ({
        organization: one(organizations, {
          fields: [people.organizationId],
          references: [organizations.id],
        }),
        owner: one(users, {
          fields: [people.ownerId],
          references: [users.id],
        }),
      }))
      ```
    - Update existing `organizationsRelations` to include `many(people)`:
      - Change `relations(organizations, ({ one }) => ({` to `relations(organizations, ({ one, many }) => ({`
      - Add `people: many(people),` alongside existing `owner` relation
    - Update existing `usersRelations` to include `many(people)`:
      - Add `people: many(people),` alongside existing relations

    **Update `src/db/schema/index.ts`**:
    - Add `export * from "./people"` before the `_relations` export line

    After file creation, run `npx drizzle-kit push` to apply the schema to the database, then run `npx tsc --noEmit` to verify no TypeScript errors.
  </action>
  <verify>
    1. `npx tsc --noEmit` passes with zero errors
    2. `npx drizzle-kit push` applies the people table (or reports it already exists)
    3. The people table has all expected columns: id, first_name, last_name, email, phone, notes, organization_id, owner_id, created_at, updated_at, deleted_at
  </verify>
  <done>
    People table schema exists with all columns, FK references to organizations and users, soft delete support. Relations file has peopleRelations and updated organizationsRelations with many(people). Schema barrel export includes people.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create people CRUD server actions</name>
  <files>
    src/app/people/actions.ts
  </files>
  <action>
    **Create `src/app/people/actions.ts`** mirroring organizations/actions.ts exactly:

    Add `"use server"` directive at top.

    **Imports:**
    - `auth` from `@/auth`
    - `db` from `@/db`
    - `people`, `organizations` from `@/db/schema`
    - `eq`, `and`, `isNull` from `drizzle-orm`
    - `revalidatePath` from `next/cache`
    - `z` from `zod`

    **Zod validation schema (`personSchema`):**
    ```
    const personSchema = z.object({
      firstName: z.string().min(1, "First name is required").max(50, "First name must be 50 characters or less"),
      lastName: z.string().min(1, "Last name is required").max(50, "Last name must be 50 characters or less"),
      email: z.string().email("Invalid email address").optional().or(z.literal("")),
      phone: z.string().max(30, "Phone must be 30 characters or less").optional().or(z.literal("")),
      notes: z.string().max(2000, "Notes must be 2000 characters or less").optional().or(z.literal("")),
      organizationId: z.string().optional().or(z.literal("")),
    })
    ```
    Also define `const updatePersonSchema = personSchema.partial()`.

    **`createPerson` action:**
    - Return type: `Promise<{ success: true; id: string } | { success: false; error: string }>`
    - Auth check: `const session = await auth()`, return error if `!session?.user?.id`
    - Validate with `personSchema.safeParse(data)`, return first issue message on failure
    - If `organizationId` is provided and non-empty, verify the org exists and is not soft-deleted:
      ```
      const org = await db.query.organizations.findFirst({
        where: and(eq(organizations.id, validated.data.organizationId), isNull(organizations.deletedAt))
      })
      if (!org) return { success: false, error: "Organization not found" }
      ```
    - Insert with `db.insert(people).values({...}).returning()`, setting empty strings to null for email, phone, notes, organizationId
    - Call `revalidatePath("/people")` and if organizationId is set, also `revalidatePath(\`/organizations/${organizationId}\`)`
    - Return `{ success: true, id: person.id }`

    **`updatePerson` action:**
    - Signature: `(id: string, data: z.infer<typeof updatePersonSchema>)`
    - Return type: `Promise<{ success: true } | { success: false; error: string }>`
    - Auth check same as create
    - Validate with `updatePersonSchema.safeParse(data)`
    - Fetch existing person: `db.query.people.findFirst({ where: and(eq(people.id, id), isNull(people.deletedAt)) })`
    - Check exists and `person.ownerId === session.user.id`
    - If organizationId is provided, validate org exists (same check as create)
    - Update with `db.update(people).set({ ...validated.data, updatedAt: new Date() }).where(eq(people.id, id))`
    - Handle empty strings -> null for optional fields before update
    - Revalidate `/people`, `/people/${id}`, and both old and new org paths if organizationId changed
    - Return `{ success: true }`

    **`deletePerson` action:**
    - Signature: `(id: string)`
    - Return type: `Promise<{ success: true } | { success: false; error: string }>`
    - Auth check, fetch person, ownership check (same pattern as update)
    - Soft delete: `db.update(people).set({ deletedAt: new Date(), updatedAt: new Date() }).where(eq(people.id, id))`
    - Revalidate `/people` and if person had an organizationId, also revalidate that org's path
    - Return `{ success: true }`

    Run `npx tsc --noEmit` to verify.
  </action>
  <verify>
    1. `npx tsc --noEmit` passes with zero errors
    2. File exports `createPerson`, `updatePerson`, `deletePerson`
    3. All three actions: check auth, validate input, check ownership (update/delete), soft-delete pattern, revalidate paths
  </verify>
  <done>
    Three server actions exist with auth guards, Zod validation, ownership checks, org existence validation, soft delete, and path revalidation matching the organizations pattern exactly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- zero TypeScript errors
2. `npx drizzle-kit push` -- people table exists in database
3. All three server actions exported and follow the return object pattern `{ success: true/false }`
4. People schema has nullable organizationId FK (not required)
5. Relations file has `peopleRelations` with organization + owner relations
6. Organizations relations updated to include `many(people)`
</verification>

<success_criteria>
- People table exists in database with correct columns and foreign keys
- CRUD server actions validate input, check auth + ownership, use soft delete
- TypeScript compilation passes
- Schema barrel export includes people
</success_criteria>

<output>
After completion, create `.planning/phases/03-people/03-01-SUMMARY.md`
</output>
